<!DOCTYPE html>
<html>
<head>
    <title>Moon Patrol</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }
        #fullscreen-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #333;
            color: #00de47;
            border: 2px solid #00de47;
            padding: 5px 10px;
            cursor: pointer;
            font-family: monospace;
            z-index: 1000;
        }
        canvas {
            max-width: 100%;
            max-height: 100vh;
        }
    </style>
</head>
<body>
<button id="fullscreen-btn">[ FULLSCREEN ]</button>
<script>
class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
        this.score = 0;
        this.lives = 3;
        this.scrollSpeed = 0.75;
        this.groundY = 200;
        this.vehicleBaseY = 188;
        this.isJumping = false;
        this.jumpSpeed = 3;
        this.gravity = 0.05;
        this.vehicleY = this.vehicleBaseY;
        this.jumpVelocity = 0;
        this.wheelRotation = 0;
        this.vehicleJiggle = 0;
        this.bullets = [];
        this.bulletSpeed = 6;
        this.rocks = [];
        this.explosions = [];
        this.isDying = false;
        this.respawnTimer = 0;
        this.isGameOver = false;
        this.ufos = [];
        this.ufoProjectiles = [];
        this.ufoSpawnTimer = 180;
        
        // New properties for terrain features
        this.groundHoles = [];
        this.mountainPoints = [];
        this.cityElements = [];
        this.groundColor = 0xff9747; // Orange ground color
        this.backgroundColor1 = 0x000066; // Dark blue sky
        this.backgroundColor2 = 0x4488ff; // Light blue sky
    }

    init() {
        this.score = 0;
        this.lives = 3;
        this.isDying = false;
        this.isGameOver = false;
        this.respawnTimer = 0;
        this.vehicleY = this.vehicleBaseY;
        this.bullets = [];
        this.rocks = [];
        this.explosions = [];
        this.ufos = [];
        this.ufoProjectiles = [];
        this.ufoSpawnTimer = 180;
        this.groundHoles = [];
        this.generateMountainPoints();
        this.generateCityElements();
    }

    create() {
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const game = this.game.canvas;
        
        fullscreenBtn.onclick = () => {
            if (!document.fullscreenElement) {
                if (game.requestFullscreen) {
                    game.requestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        };

        // Instructions text
        this.add.text(200, 35, '[SPACE = JUMP, ENTER = FIRE]', {
            fill: '#00de47',
            fontSize: '12px',
            fontFamily: 'monospace'
        }).setOrigin(0.5);

        this.scoreText = this.add.text(16, 8, 'SCORE: ' + this.score, {
            fill: '#00de47',
            fontSize: '22px',
            fontFamily: 'monospace'
        });

        this.livesText = this.add.text(280, 8, 'LIVES: ' + this.lives, {
            fill: '#00de47',
            fontSize: '22px',
            fontFamily: 'monospace'
        });

        // Initialize graphics objects
        this.backgroundMountains = this.add.graphics();
        this.backgroundCity = this.add.graphics();
        this.ground = this.add.graphics();
        this.vehicle = this.add.graphics();
        this.bulletsGraphics = this.add.graphics();
        this.rocksGraphics = this.add.graphics();
        this.explosionsGraphics = this.add.graphics();
        this.ufosGraphics = this.add.graphics();
        this.ufoProjectilesGraphics = this.add.graphics();

        this.groundSegments = [];
        for (let i = 0; i < 41; i++) {
            this.groundSegments.push({
                x: i * 10,
                y: this.groundY + Math.sin(i * 0.5) * 3
            });
        }

        // Mobile controls
        this.setupMobileControls();
        
        // Keyboard controls
        this.setupKeyboardControls();
    }

    setupMobileControls() {
        // Jump button
        this.jumpBtn = this.add.graphics();
        this.jumpBtn.lineStyle(2, 0x00de47);
        this.jumpBtn.strokeCircle(100, 270, 30);
        
        // Fire button
        this.fireBtn = this.add.graphics();
        this.fireBtn.lineStyle(2, 0x00de47);
        this.fireBtn.strokeRect(250, 240, 60, 60);
        
        // Button labels
        this.add.text(100, 270, 'JUMP', {
            fill: '#ffde47',
            fontSize: '12px'
        }).setOrigin(0.5);
        
        this.add.text(280, 270, 'FIRE', {
            fill: '#ffde47',
            fontSize: '12px'
        }).setOrigin(0.5);

        // Make buttons interactive
        this.jumpBtn.setInteractive(
            new Phaser.Geom.Circle(100, 270, 30),
            Phaser.Geom.Circle.Contains
        );
        
        this.fireBtn.setInteractive(
            new Phaser.Geom.Rectangle(250, 240, 60, 60),
            Phaser.Geom.Rectangle.Contains
        );

        this.jumpBtn.on('pointerdown', () => {
            if (!this.isDying && !this.isJumping) {
                this.isJumping = true;
                this.jumpVelocity = -this.jumpSpeed;
            }
        });
        
        this.fireBtn.on('pointerdown', () => {
            if (!this.isDying) {
                this.shoot();
            }
        });
    }

    setupKeyboardControls() {
        this.input.keyboard.on('keydown-SPACE', () => {
            if (!this.isDying && !this.isJumping) {
                this.isJumping = true;
                this.jumpVelocity = -this.jumpSpeed;
            }
        });

        this.input.keyboard.on('keydown-ENTER', () => {
            if (!this.isDying) {
                this.shoot();
            }
        });
    }
    generateMountainPoints() {
        this.mountainPoints = [];
        let x = 0;
        while (x < 800) {
            const height = 50 + Math.random() * 50;
            this.mountainPoints.push({
                x: x,
                y: 150 - height
            });
            x += 5 + Math.random() * 14;
        }
    }

    generateCityElements() {
        this.cityElements = [];
        let x = 0;
        while (x < 800) {
            const height = 30 + Math.random() * 40;
            const width = 15 + Math.random() * 20;
            this.cityElements.push({
                x: x,
                y: this.groundY - height,
                width: width,
                height: height,
                type: Math.floor(Math.random() * 3)
            });
            x += width + 10 + Math.random() * 20;
        }
    }

    drawBackground() {
        // Draw gradient sky
        /*
        const gradient = this.add.graphics();
        gradient.clear();
        for (let y = 0; y < 150; y++) {
            const ratio = y / 150;
            const color = Phaser.Display.Color.Interpolate.ColorWithColor(
                Phaser.Display.Color.ValueToColor(this.backgroundColor1),
                Phaser.Display.Color.ValueToColor(this.backgroundColor2),
                150,
                y
            );
            gradient.lineStyle(1, color, 1);
            gradient.lineBetween(0, y, 400, y);
        }
        */
        // Draw mountains
        this.backgroundMountains.clear();
        this.backgroundMountains.lineStyle(2, 0x0000de);
        this.backgroundMountains.beginPath();
        this.mountainPoints.forEach((point, i) => {
            if (i === 0) {
                this.backgroundMountains.moveTo(point.x, 300);
            }
            this.backgroundMountains.lineTo(point.x, point.y);
            if (i === this.mountainPoints.length - 1) {
                this.backgroundMountains.lineTo(point.x, 300);
            }
        });
        this.backgroundMountains.closePath();
        this.backgroundMountains.fillStyle(0x009797, 1);
        this.backgroundMountains.fill();
        this.backgroundMountains.strokePath();

        // Draw city
        this.backgroundCity.clear();
        this.backgroundCity.lineStyle(2, 0xffde47);
        this.backgroundCity.fillStyle(0x00de47, 1);
        this.cityElements.forEach(building => {
            // Draw wider platform base
            this.backgroundCity.fillRect(
                building.x - 20, // Extend 20px left
                this.groundY - 5,
                building.width + 40, // Extend 20px right
                45 // Extend below ground level
            );
        });
        // Then draw all buildings on top
        this.cityElements.forEach(building => {
            switch(building.type) {
                case 0:
                    this.drawBuilding(building);
                    break;
                case 1:
                    this.drawDomedBuilding(building);
                    break;
                case 2:
                    this.drawAntennaBuilding(building);
                    break;
            }
        });    
    }

    drawBuilding(building) {
    // Only draw the building structure, no platform
    this.backgroundCity.strokeRect(
        building.x, 
        building.y,
        building.width,
        building.height
    );
    this.backgroundCity.fillStyle(0x00de47, 1);
    this.backgroundCity.fillRect(building.x, building.y, building.width, building.height);
    this.backgroundCity.fill();
}

drawDomedBuilding(building) {
    // Only draw the domed building structure, no platform
    this.backgroundCity.beginPath();
    this.backgroundCity.moveTo(building.x, building.y + building.height);
    this.backgroundCity.lineTo(building.x, building.y + building.height/2);
    this.backgroundCity.arc(
        building.x + building.width/2,
        building.y + building.height/2,
        building.width/2,
        Math.PI,
        0,
        true
    );
    this.backgroundCity.lineTo(
        building.x + building.width,  
        building.y + building.height
    );
    this.backgroundCity.strokePath();
    this.backgroundCity.fillStyle(0x00de47, 1);
    this.backgroundCity.fill();
}

drawAntennaBuilding(building) {
    // Only draw the building and antenna, no platform
    this.backgroundCity.strokeRect(
        building.x, 
        building.y,
        building.width,
        building.height
    );
    this.backgroundCity.fillStyle(0x00de47, 1);
    this.backgroundCity.fillRect(building.x, building.y, building.width, building.height);
    
    const antennaHeight = building.height * 0.4;
    this.backgroundCity.beginPath();
    this.backgroundCity.moveTo(
        building.x + building.width/2,
        building.y
    );
    this.backgroundCity.lineTo(
        building.x + building.width/2,
        building.y - antennaHeight
    );
    this.backgroundCity.strokePath();
    this.backgroundCity.fillStyle(0x00de47, 1);
    this.backgroundCity.fill();
}

    // draws holes
    drawHoles() {
        this.ground.lineStyle(3, 0x000000);  // Black outline for holes
        this.ground.fillStyle(0x000000, 1);  // Black fill for holes
        
        this.groundHoles.forEach(hole => {
            // Draw an oval/ellipse shape for the hole
            this.ground.beginPath();
            const holeY = this.groundY + 2; // Slightly below ground level
            this.ground.ellipse(hole.x, holeY, hole.width/2, 10);
            this.ground.closePath();
            this.ground.fill();
            this.ground.strokePath();
        });
    }

    // Modify the drawGround method to be simpler - just draw and fill the lumpy ground
    drawGround() {
        this.ground.clear();
        
        // First draw the filled ground
        this.ground.lineStyle(3, this.groundColor);
        this.ground.beginPath();
        this.ground.moveTo(0, 300);
        
        // Draw the ground line with gaps for holes
        let currentX = 0;
        this.groundSegments.forEach((segment, i) => {
            const lumpY = segment.y + Math.sin(i * 0.5) * 3;
            
            // Check if this segment is part of a hole
            const isHole = this.groundHoles.some(hole => 
                Math.abs(hole.x - segment.x) < hole.width/2
            );
            
            if (isHole) {
                // Draw the hole as a dip in the ground line
                this.ground.lineTo(segment.x, lumpY + 15);
            } else {
                this.ground.lineTo(segment.x, lumpY);
            }
        });
        
        // Complete the ground path
        this.ground.lineTo(400, 300);
        this.ground.lineTo(0, 300);
        
        // Fill and stroke
        this.ground.fillStyle(this.groundColor, 1);
        this.ground.fill();
        this.ground.strokePath();
    }

 
    addUfo() {
        this.ufos.push({
            x: 420,
            y: 80 + Math.random() * 60,
            width: 30,
            height: 15,
            startY: 80 + Math.random() * 60,
            angle: 0,
            shotTimer: 60 + Math.random() * 60
        });
    }

    ufoShoot(ufo) {
        this.ufoProjectiles.push({
            x: ufo.x,
            y: ufo.y + ufo.height/2,
            vy: 4,
            width: 1,
            height: 6
        });
    }

    addExplosion(x, y, color = 0xae3628, scale = 1.5) {
        this.explosions.push({
            x: x,
            y: y,
            frame: 0,
            maxFrames: 20,
            scale: scale,
            color: color,
            alpha: 1.0
        });
    }

    drawVehicle(x, y) {
    if (!this.isDying) {
        this.vehicle.clear();
        this.vehicle.lineStyle(2, 0xde00de);
        
        // Main body
        this.vehicle.fillStyle(0xde00de, 1);
        this.vehicle.fillRect(x - 18, y - 6, 40, 8);
        
        // Top turret
        this.vehicle.fillStyle(0x00deff, .8);
        this.vehicle.fillRect(x - 4, y - 14, 12, 8);
        this.vehicle.strokeRect(x - 5, y - 14, 13, 9)
        
        // Front cannon
        this.vehicle.fillStyle(0xde00de, 1);
        this.vehicle.fillRect(x + 20, y - 6, 8, 4);
        
        // Wheels with rotation
        this.vehicle.lineStyle(2, 0x111111);
        
        // Define wheel positions
        const wheelPositions = [-14, 0, 15];
        const wheelOffset = 6;
        
        wheelPositions.forEach(pos => {
            const wheelX = x + pos;
            const wheelY = y + 4 + this.vehicleJiggle;
            
            // Draw spokes for rotation effect
            this.vehicle.beginPath();
            this.vehicle.moveTo(
                wheelX - wheelOffset * Math.cos(this.wheelRotation),
                wheelY - wheelOffset * Math.sin(this.wheelRotation)
            );
            this.vehicle.lineTo(
                wheelX + wheelOffset * Math.cos(this.wheelRotation),
                wheelY + wheelOffset * Math.sin(this.wheelRotation)
            );
            this.vehicle.strokePath();

            // Draw perpendicular spoke
            this.vehicle.beginPath();
            this.vehicle.moveTo(
                wheelX - wheelOffset * Math.sin(this.wheelRotation),
                wheelY + wheelOffset * Math.cos(this.wheelRotation)
            );
            this.vehicle.lineTo(
                wheelX + wheelOffset * Math.sin(this.wheelRotation),
                wheelY - wheelOffset * Math.cos(this.wheelRotation)
            );
            this.vehicle.strokePath();

            // Draw wheel circle
            this.vehicle.strokeCircle(wheelX, wheelY, 6);
            this.vehicle.fillStyle(0x222222, 1);
            this.vehicle.fill();
        });
    }
}

    shoot() {
        this.bullets.push({
            x: 128,
            y: this.vehicleY - 4,
            vx: this.bulletSpeed,
            vy: 0,
            type: 'front'
        });

        this.bullets.push({
            x: 100,
            y: this.vehicleY - 16,
            vx: 0,
            vy: -this.bulletSpeed,
            type: 'top'
        });
    }

    drawBullets() {
        this.bulletsGraphics.clear();
        this.bulletsGraphics.lineStyle(2, 0xaaaaaa);

        this.bullets.forEach(bullet => {
            if (bullet.type === 'front') {
                this.bulletsGraphics.strokeRect(bullet.x, bullet.y, 8, 2);
            } else {
                this.bulletsGraphics.strokeRect(bullet.x - 1, bullet.y, 2, 8);
            }
        });
    }

    drawUfos() {
        this.ufosGraphics.clear();
        this.ufosGraphics.lineStyle(2, 0xaaaaaa);
        
        this.ufos.forEach(ufo => {
            // UFO body
            this.ufosGraphics.beginPath();
            this.ufosGraphics.moveTo(ufo.x - ufo.width/2, ufo.y);
            this.ufosGraphics.lineTo(ufo.x - ufo.width/4, ufo.y - ufo.height/2);
            this.ufosGraphics.lineTo(ufo.x + ufo.width/4, ufo.y - ufo.height/2);
            this.ufosGraphics.lineTo(ufo.x + ufo.width/2, ufo.y);
            this.ufosGraphics.lineTo(ufo.x + ufo.width/4, ufo.y + ufo.height/2);
            this.ufosGraphics.lineTo(ufo.x - ufo.width/4, ufo.y + ufo.height/2);
            this.ufosGraphics.closePath();
            this.ufosGraphics.fillStyle(0x999999, 1);
            this.ufosGraphics.fill();
            this.ufosGraphics.strokePath();

            // UFO dome
            this.ufosGraphics.beginPath();
            this.ufosGraphics.arc(ufo.x, ufo.y - ufo.height/4, ufo.width/4, 0, Math.PI, true);
            this.ufosGraphics.fillStyle(0xffde47, 1);
            this.ufosGraphics.fill();
            this.ufosGraphics.strokePath();
        });
    }

    drawUfoProjectiles() {
        this.ufoProjectilesGraphics.clear();
        this.ufoProjectilesGraphics.lineStyle(2, 0xff0000);
        
        this.ufoProjectiles.forEach(proj => {
            this.ufoProjectilesGraphics.strokeRect(proj.x - 1, proj.y, proj.width, proj.height);
        });
    }

    drawRocks() {
        this.rocksGraphics.clear();
        this.rocksGraphics.lineStyle(2, 0x898074);
        
        this.rocks.forEach(rock => {
            // Use the rock's x position to generate consistent points
            // by using it as a seed for the random points
            const seed = Math.floor(rock.x); // Use rock's initial position as seed
            
            this.rocksGraphics.beginPath();
            
            // Start at bottom left
            this.rocksGraphics.moveTo(rock.x, rock.y + rock.height);
            
            // Create fixed points for this rock
            const points = [
                { x: rock.x, y: rock.y + rock.height }, // bottom left
                { x: rock.x + rock.width * 0.2, y: rock.y + rock.height * 0.3 },
                { x: rock.x + rock.width * 0.5, y: rock.y },
                { x: rock.x + rock.width * 0.8, y: rock.y + rock.height * 0.4 },
                { x: rock.x + rock.width, y: rock.y + rock.height } // bottom right
            ];
            
            // Draw the main shape
            points.forEach(point => {
                this.rocksGraphics.lineTo(point.x, point.y);
            });
            
            this.rocksGraphics.closePath();
            this.rocksGraphics.strokePath();
            this.rocksGraphics.fillStyle(0xaebec9, 1);
            this.rocksGraphics.fill();

            // Add internal lines for detail
            this.rocksGraphics.beginPath();
            this.rocksGraphics.moveTo(points[1].x, points[1].y);
            this.rocksGraphics.lineTo(points[3].x, points[3].y);
            this.rocksGraphics.strokePath();

            this.rocksGraphics.beginPath();
            this.rocksGraphics.moveTo(points[2].x, points[2].y);
            this.rocksGraphics.lineTo(points[2].x, points[4].y);
            this.rocksGraphics.strokePath();
            
        });
    }

    drawExplosions() {
        this.explosionsGraphics.clear();

        this.explosions.forEach(explosion => {
            const alpha = 1 - (explosion.frame / explosion.maxFrames);
            this.explosionsGraphics.lineStyle(2, explosion.color || 0xae3628, alpha);
            const size = 20 * (1 - explosion.frame / explosion.maxFrames) * explosion.scale;
            const segments = 8;
            const angleStep = (Math.PI * 2) / segments;

            for (let i = 0; i < segments; i++) {
                const angle = i * angleStep;
                const x1 = explosion.x + Math.cos(angle) * size;
                const y1 = explosion.y + Math.sin(angle) * size;
                const x2 = explosion.x + Math.cos(angle + angleStep/2) * (size * 0.5);
                const y2 = explosion.y + Math.sin(angle + angleStep/2) * (size * 0.5);
                
                this.explosionsGraphics.beginPath();
                this.explosionsGraphics.moveTo(x1, y1);
                this.explosionsGraphics.lineTo(x2, y2);
                this.explosionsGraphics.strokePath();
            }
        });
    }

    addRock() {
        if (Math.random() < 0.3 && this.rocks.length < 3) {
            // Check if there's a hole where we want to place the rock
            const rockX = 420;
            const isHoleAtPosition = this.groundHoles.some(hole => 
                Math.abs(hole.x - rockX) < hole.width/2
            );
            
            if (!isHoleAtPosition) {
                this.rocks.push({
                    x: rockX,
                    y: this.groundY - 18,
                    width: 25,
                    height: 25
                });
            }
        }
    }

    gameOver() {
        this.isGameOver = true;
        
        this.add.text(200, 150, 'GAME OVER', {
            fill: '#000000',
            fontSize: '32px',
            fontFamily: 'monospace'
        }).setOrigin(0.5);

        const restartBtn = this.add.graphics();
        restartBtn.lineStyle(2, 0x000000);
        restartBtn.strokeRect(140, 220, 100, 40);

        this.add.text(190, 240, 'RESTART', {
            fill: '#000000',
            fontSize: '16px'
        }).setOrigin(0.5);

        restartBtn.setInteractive(
            new Phaser.Geom.Rectangle(150, 220, 100, 40),
            Phaser.Geom.Rectangle.Contains
        );

        restartBtn.on('pointerdown', () => {
            this.init();
            this.scene.restart();
        });
    }

    checkBuggyCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
        return Math.abs((x1 + w1/2) - (x2 + w2/2)) < (w1 + w2)/2 &&
               Math.abs((y1 + h1/2) - (y2 + h2/2)) < (h1 + h2)/2;
    }

    update() {
    if (this.isGameOver) return;

    // Randomly add new holes (with lower frequency)
    if (Math.random() < 0.0005) { // Much lower chance to spawn holes
        this.groundHoles.push({
            x: 420, // Start off-screen
            width: 50,  // Make them wider
            active: true // Flag to track if hole can cause damage
        });
    }  

    if (this.isDying) {
        if (this.respawnTimer > 0) {
            this.respawnTimer--;
            if (this.respawnTimer <= 0) {
                this.isDying = false;
                this.vehicleY = this.vehicleBaseY;
                this.isJumping = false;
                this.jumpVelocity = 0;
            }
        }
    } else {
        if (this.isJumping) {
            this.jumpVelocity += this.gravity;
            this.vehicleY += this.jumpVelocity;

            if (this.vehicleY >= this.vehicleBaseY) {
                this.vehicleY = this.vehicleBaseY;
                this.isJumping = false;
                this.jumpVelocity = 0;
            }
        }

        // Check if buggy is over a hole
        if (!this.isDying && !this.isJumping) {
            const buggyX = 100;  // Center of the buggy
            const isOverHole = this.groundHoles.some(hole => {
                if (!hole.active) return false; // Skip inactive holes
                const holeStart = hole.x - hole.width/2;
                const holeEnd = hole.x + hole.width/2;
                const isOver = buggyX > holeStart && buggyX < holeEnd;
                if (isOver) {
                    hole.active = false; // Prevent multiple collisions with same hole
                    return true;
                }
                return false;
            });
            
            if (isOverHole) {
                this.addExplosion(100, this.vehicleY);
                this.lives--;
                this.livesText.setText('LIVES: ' + this.lives);
                
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    this.isDying = true;
                    this.respawnTimer = 100;
                    // Make the buggy fall visibly
                    this.vehicleY += 30;
                }
            }
        }

        // Check UFO collision with buggy
        this.ufos.forEach((ufo, i) => {
            if (this.checkBuggyCollision(
                100 - 20, this.vehicleY - 8, 40, 16,
                ufo.x - ufo.width/2, ufo.y - ufo.height/2, ufo.width, ufo.height
            )) {
                this.addExplosion(ufo.x, ufo.y, 0xff0000);
                this.addExplosion(100, this.vehicleY);
                this.ufos.splice(i, 1);
                this.lives--;
                this.livesText.setText('LIVES: ' + this.lives);
                
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    this.isDying = true;
                    this.respawnTimer = 100;
                }
            }
        });
    }
    

        // Update UFOs
        this.ufoSpawnTimer--;
        if (this.ufoSpawnTimer <= 0) {
            this.addUfo();
            this.ufoSpawnTimer = 180;
        }

        // Update UFO positions and shooting
        for (let i = this.ufos.length - 1; i >= 0; i--) {
            const ufo = this.ufos[i];
            ufo.x -= 1.5;
            ufo.angle += 0.05;
            ufo.y = ufo.startY + Math.sin(ufo.angle) * 30;

            ufo.shotTimer--;
            if (ufo.shotTimer <= 0) {
                this.ufoShoot(ufo);
                ufo.shotTimer = 120 + Math.random() * 60;
            }

            if (ufo.x < -30) {
                this.ufos.splice(i, 1);
            }
        }

        // Update bullets and check collisions
        for (let j = this.bullets.length - 1; j >= 0; j--) {
            const bullet = this.bullets[j];
            bullet.x += bullet.vx;
            bullet.y += bullet.vy;

            // Check rocks first
            for (let k = this.rocks.length - 1; k >= 0; k--) {
                const rock = this.rocks[k];
                if (bullet.x >= rock.x && bullet.x <= rock.x + rock.width &&
                    bullet.y >= rock.y && bullet.y <= rock.y + rock.height) {
                    this.addExplosion(rock.x + rock.width/2, rock.y + rock.height/2);
                    this.rocks.splice(k, 1);
                    this.bullets.splice(j, 1);
                    this.score += 100;
                    break;
                }
            }

            // Then check UFOs
            for (let i = this.ufos.length - 1; i >= 0; i--) {
                const ufo = this.ufos[i];
                if (bullet.x >= ufo.x - ufo.width/2 && 
                    bullet.x <= ufo.x + ufo.width/2 &&
                    bullet.y >= ufo.y - ufo.height/2 && 
                    bullet.y <= ufo.y + ufo.height/2) {
                    this.addExplosion(ufo.x, ufo.y, 0xff0000);
                    this.ufos.splice(i, 1);
                    this.bullets.splice(j, 1);
                    this.score += 200;
                    break;
                }
            }

            // Remove off-screen bullets
            if (bullet.x > 400 || bullet.x < 0 || bullet.y > 300 || bullet.y < 0) {
                this.bullets.splice(j, 1);
            }
        }

        // Update UFO projectiles
        for (let i = this.ufoProjectiles.length - 1; i >= 0; i--) {
            const proj = this.ufoProjectiles[i];
            proj.y += proj.vy;

            if (!this.isDying &&
                Math.abs(100 - proj.x) < 20 &&
                Math.abs(this.vehicleY - proj.y) < 20) {
                this.addExplosion(100, this.vehicleY, 0xff0000);
                this.ufoProjectiles.splice(i, 1);
                this.lives--;
                this.livesText.setText('LIVES: ' + this.lives);
                
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    this.isDying = true;
                    this.respawnTimer = 100;
                }
                continue;
            }

            if (proj.y > 300) {
                this.ufoProjectiles.splice(i, 1);
            }
        }
        // Update hole positions and cleanup
        for (let i = this.groundHoles.length - 1; i >= 0; i--) {
            this.groundHoles[i].x -= this.scrollSpeed;
            // Remove holes that are off screen
            if (this.groundHoles[i].x < -40) {
                this.groundHoles.splice(i, 1);
            }
        }        
        // Update rocks and check collisions
        for (let i = this.rocks.length - 1; i >= 0; i--) {
            const rock = this.rocks[i];
            rock.x -= this.scrollSpeed;

            if (!this.isDying && 
                this.checkBuggyCollision(
                    100 - 20, this.vehicleY - 8, 40, 16,
                    rock.x, rock.y, rock.width, rock.height
                )) {
                this.addExplosion(rock.x + rock.width/2, rock.y + rock.height/2);
                this.addExplosion(100, this.vehicleY);
                this.rocks.splice(i, 1);
                this.lives--;
                this.livesText.setText('LIVES: ' + this.lives);
                
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    this.isDying = true;
                    this.respawnTimer = 100;
                }
                continue;
            }

            if (rock.x < -20) {
                this.rocks.splice(i, 1);
            }
        }

        if (Math.random() < 0.02) {
            this.addRock();
        }

        // Scroll ground
        for (let i = 0; i < this.groundSegments.length; i++) {
            this.groundSegments[i].x -= this.scrollSpeed;
        }

        if (this.groundSegments[0].x <= -10) {
            this.groundSegments.shift();
            this.groundSegments.push({
                x: this.groundSegments[this.groundSegments.length - 1].x + 10,
                y: this.groundY + Math.sin(this.groundSegments.length * 0.5) * 3
            });
        }

        // Update explosions
        for (let i = this.explosions.length - 1; i >= 0; i--) {
            this.explosions[i].frame++;
            if (this.explosions[i].frame >= this.explosions[i].maxFrames) {
                this.explosions.splice(i, 1);
            }
        }

        // Before drawing vehicle
        if (!this.isDying) {
            this.wheelRotation += this.scrollSpeed * 0.5;
            this.vehicleJiggle = Math.sin(this.wheelRotation * 0.5) * 2;
        }

        // Draw everything
        this.drawBackground();
        this.drawGround();
        this.drawRocks();
        this.drawVehicle(100, this.vehicleY);
        this.drawBullets();
        this.drawUfos();
        this.drawUfoProjectiles();
        this.drawExplosions();

        // Update score
        this.scoreText.setText('SCORE: ' + this.score);
    }
}
const config = {
    type: Phaser.AUTO,
    width: 400,
    height: 300,
    backgroundColor: '#000000',
    scene: GameScene,
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    }
};

new Phaser.Game(config);
</script>
</body>
</html>                